pipeline {
  agent any
  tools { nodejs 'nodejs18.20.2'; jdk 'openjdk17'; maven 'maven3.9.11' } // set from jenkins -> Mange Jenkins -> Tools
  options {
    // Donâ€™t waste time checking out twice
    skipDefaultCheckout(true)
    // Avoid overlapping builds if pushes are frequent
    disableConcurrentBuilds()    
  }

  environment {
    FRONTEND_DIR = 'stan_blog_web'
    BACKEND_DIR  = 'stan_blog_service'
    EMAIL_TO     = credentials('CD_STAGING_EMAIL_TO')
    HARBOR_URL      = 'harbor.stanli.site'
    HARBOR_PROJECT  = 'stan-blog-staging'
    HARBOR_CRED_ID  = 'SELF_HOSTED_HARBOR'
    REMOTE_REPO_URL = 'https://gitlab.stanli.site/stanli/stan-blog'
    REMOTE_REPO_CRED_ID = 'a214f604-c207-4464-8d6f-f8b3bbfdb4e3'
    JWT_SECRET_ACCESS = credentials('JWT_SECRET_ACCESS')
    JWT_SECRET_REFRESH = credentials('JWT_SECRET_REFRESH')
    SSH_USER = credentials('SERVER_SSH_USER')
    SSH_HOST = credentials('SERVER_SSH_HOST')
    SSH_PORT = credentials('SERVER_SSH_PORT')
    SERVER_DOCKER_COMPOSE_PATH = credentials('SERVER_DOCKER_COMPOSE_PATH')
  }

  stages {
    stage('Checkout staging') {
      steps {
        checkout([$class: 'GitSCM',
          branches: [[name: '*/staging']],
          userRemoteConfigs: [[url: "${env.REMOTE_REPO_URL}", credentialsId: "${env.REMOTE_REPO_CRED_ID}"]]
        ])
        script {
          def shortSha = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          env.IMAGE_TAG = "${env.BUILD_NUMBER}-${shortSha}"
          echo "IMAGE_TAG resolved to ${env.IMAGE_TAG}"
          env.IMG_BACKEND = "${env.HARBOR_URL}/${env.HARBOR_PROJECT}/stan-blog-backend:${env.IMAGE_TAG}" 
          env.IMG_FRONTEND = "${env.HARBOR_URL}/${env.HARBOR_PROJECT}/stan-blog-frontend:${env.IMAGE_TAG}" 
        }
      }
    }

    stage('Tests') {
      parallel {
        stage('Backend Test') {
          steps {
            dir("${BACKEND_DIR}") {
              echo "ðŸ” [Backend] testing (changes detected on staging)â€¦"
              sh '''
                set -eux
                mvn test
              '''
            }
          }
        }

        stage('Frontend Test') {
          steps {
            dir("${FRONTEND_DIR}") {
              echo "ðŸ” [Frontend] testing (changes detected on staging)â€¦"
              sh '''
                set -eux
                npm ci || npm install
                npm run lint
              '''
            }
          }
        }
      }
    }

    stage('Build & Push Images') {
      parallel {
        stage('Build & Push Backend Image') {
          steps {
            dir("${BACKEND_DIR}") {
              // Build & Push Backend Image
              withCredentials([
                file(credentialsId: 'SPRING_PROFILES', variable: 'BACKEND_PROFILES_FILE'),
                usernamePassword(credentialsId: "${env.HARBOR_CRED_ID}",
                                 usernameVariable: 'HARBOR_USER',
                                 passwordVariable: 'HARBOR_PASS')
              ]) {
                script {
                  sh """
                    set -eux
                    # Copy application-prod.yml to build context
                    cp "\$BACKEND_PROFILES_FILE" src/main/resources/application-prod.yml

                    echo "[Docker] Login Harbor"
                    echo "\$HARBOR_PASS" | docker login ${env.HARBOR_URL} -u "\$HARBOR_USER" --password-stdin
                  
                    echo "[Docker] Build backend image \$IMG_BACKEND"
                    docker build -t \$IMG_BACKEND -f Dockerfile .
                  
                    echo "[Docker] Push backend image"
                    docker push \$IMG_BACKEND

                    # Remove sensitive files after build
                    rm -f src/main/resources/application-prod.yml
                  """
                }
              }
            }
          }
        }

        stage('Build & Push Frontend Image') {
          steps {
            dir("${FRONTEND_DIR}") {
              // Inject .env.production as file credential
              withCredentials([
                file(credentialsId: 'FRONTEND_ENV', variable: 'FRONTEND_ENV_FILE'),
                file(credentialsId: 'FRONTEND_CUSTOMIZATION_FILE', variable: 'FRONTEND_CUSTOMIZATION_FILE'),
                usernamePassword(credentialsId: "${env.HARBOR_CRED_ID}",
                                 usernameVariable: 'HARBOR_USER',
                                 passwordVariable: 'HARBOR_PASS')
              ]) {
                script {
                  sh """
                    set -eux
                    # Ensure env directory exists
                    mkdir -p env
                    # Copy .env.production and customization file to build context
                    cp "\$FRONTEND_ENV_FILE" env/.env.production
                    cp "\$FRONTEND_CUSTOMIZATION_FILE" customization.json

                    echo "[Docker] Login Harbor"
                    echo "\$HARBOR_PASS" | docker login ${env.HARBOR_URL} -u "\$HARBOR_USER" --password-stdin

                    echo "[Docker] Build frontend image \$IMG_FRONTEND"
                    docker build -t \$IMG_FRONTEND -f Dockerfile .

                    echo "[Docker] Push frontend image"
                    docker push \$IMG_FRONTEND

                    # Remove sensitive files after build
                    rm -f env/.env.production
                  """
                }
              }
            }
          }
        }
      }
    }
    stage('Deploy to Staging') {
      steps {
        sshagent(credentials: ['SERVER_SSH_KEY']) {
          sh """
            set -eux
            
            mkdir -p ~/.ssh
            touch ~/.ssh/known_hosts
            chmod 600 ~/.ssh/known_hosts
            ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

            # Use IMAGE_TAG as temp env file and pass to compose
            echo "IMAGE_TAG=${env.IMAGE_TAG}" > image_tag.env
            scp -P ${env.SSH_PORT} image_tag.env ${env.SSH_USER}@${env.SSH_HOST}:/tmp/stan-blog-image.env
            rm image_tag.env

            # Remotely run compose pull/up
            ssh -p ${env.SSH_PORT} ${env.SSH_USER}@${env.SSH_HOST}\\
            "
              cd "${env.SERVER_DOCKER_COMPOSE_PATH}"
              sudo docker compose --env-file /tmp/stan-blog-image.env pull
              sudo docker compose --env-file /tmp/stan-blog-image.env up -d
            "
          """
        }
      }
    }
  }

  post {
    always {
      script {
        def summary = """
          Job: ${env.JOB_NAME}
          Build: #${env.BUILD_NUMBER}
          Branch: staging
          Result: ${currentBuild.currentResult}
          Image Tags:
            BE -> ${env.HARBOR_URL}/${env.HARBOR_PROJECT}/stan_blog_service:${env.IMAGE_TAG}
            FE -> ${env.HARBOR_URL}/${env.HARBOR_PROJECT}/stan_blog_web:${env.IMAGE_TAG}

          Console: ${env.BUILD_URL}console
        """.stripIndent()

        emailext(
          to: env.EMAIL_TO,
          subject: "[${env.JOB_NAME}] #${env.BUILD_NUMBER} ${currentBuild.currentResult}",
          body: summary,
          mimeType: 'text/plain'
        )
      }
      cleanWs()
    }
  }
}
